#pragma once

#include <string>
#include <iostream>
#include <sstream>
#include <string>
#include <tuple>
#include <iomanip>
#include <map>
#include <vector>
#include <array>
#include <type_traits>
#include <functional>
#include <string_view>
#include <algorithm>
#include <map>
#include <memory>

#include <unordered_map>

#include <typeinfo>

#include <ffi.h>
#include <FFI_reflection_types.h> 

#include <Reflection.h>

//#include <types.h>


namespace SAMY{
namespace Reflection {
namespace FFI {

template< typename T>
struct show;

// These types are used to "fake" the bool since they are not provided by libffi
template< std::size_t S >
struct Bool_FFI{};

template<>
struct Bool_FFI<1>{
   using type = UINT8;
};

template<>
struct Bool_FFI<2>{
   using type = UINT16;
};

template<>
struct Bool_FFI<4>{
   using type = UINT32;
};

template<>
struct Bool_FFI<8>{
   using type = UINT64;
};

// Better use a vector in combination with the open62541 code generated types numeration
// Use open62541 DataTypes arrays to generate all those types at launchtime. Access them directly by the data type index UA_NAMEOFTHE_TYPE (this has an associated number generated by open62541)
extern std::map< std::string, ffi_type* > typeName_ffiType_map; // Map from type name to ffi_type


template< typename T, typename Enable = void > // If it is not an unnamed member union (regular type so to say)
struct FFI_Type_Wrapper{
    using M = decltype( samy_reflect_members( std::declval<T>() ) );
    constexpr static const std::size_t number_elements = M::number_members::value;
    inline static ffi_type* type_elements[ number_elements + 1];
    inline static ffi_type ffiType = {.size = 0, .alignment = 0, .type = FFI_TYPE_STRUCT, .elements = type_elements };
};

/* Partial specialization only used for the case of tagged unions, where we use the type of the unnamed member union to store the type information of the member union (if TestUnion is the tagged union type, this type will be then TestUnion TestUnion::* and for this type there is no samy_reflect_members( std::declval<T>() ) structure and size is fixed like this */
template<typename T>
struct FFI_Type_Wrapper< T, typename std::enable_if< std::is_member_object_pointer< T >::value >::type > {
    constexpr static const std::size_t number_elements = std::integral_constant< std::size_t, 1 >::value;
    inline static ffi_type* type_elements[ number_elements + 1 ] = {NULL, NULL};
    inline static ffi_type ffiType = {.size = 0, .alignment = 0, .type = FFI_TYPE_STRUCT, .elements = type_elements };
};

// Total specialization for bool since it is not provided by libffi. Values set in total spezialization of generate_FFI_types for bool
template<>						
struct FFI_Type_Wrapper<bool>{						
    constexpr static std::size_t number_elements = 1;				
    inline static ffi_type ffiType;
};


// Macros for adding the structures, templates and functions for the libffi basic types. Basic types are used to build structs, unions, etc.
FFI_TYPEDEF_MOD(uint8, UINT8, FFI_TYPE_UINT8)
FFI_TYPEDEF_MOD(sint8, SINT8, FFI_TYPE_SINT8)
FFI_TYPEDEF_MOD(uint16, UINT16, FFI_TYPE_UINT16)
FFI_TYPEDEF_MOD(sint16, SINT16, FFI_TYPE_SINT16)
FFI_TYPEDEF_MOD(uint32, UINT32, FFI_TYPE_UINT32)
FFI_TYPEDEF_MOD(sint32, SINT32, FFI_TYPE_SINT32)
FFI_TYPEDEF_MOD(uint64, UINT64, FFI_TYPE_UINT64)
FFI_TYPEDEF_MOD(sint64, SINT64, FFI_TYPE_SINT64)
FFI_TYPEDEF_MOD(pointer, void*, FFI_TYPE_POINTER)
FFI_TYPEDEF_MOD(float, float, FFI_TYPE_FLOAT)
FFI_TYPEDEF_MOD(double, double, FFI_TYPE_DOUBLE)



template <typename T>
constexpr auto generate_FFI_types_composed( const T& t ) -> std::enable_if_t< is_reflection<T>::value >;

template <typename T>
auto generate_FFI_types( const T& t ) -> std::enable_if_t< is_reflection<T>::value > {
  using A = decltype( samy_reflect_members( t ) );
  constexpr auto typeName = A::name();
  if( typeName_ffiType_map.find( std::string{typeName} ) != typeName_ffiType_map.end() )
     return ;

  typeName_ffiType_map.insert ( std::pair< std::string, ffi_type* >( std::string{typeName}, &FFI_Type_Wrapper< T >::ffiType ) );

  generate_FFI_types_composed( t );
}

template <typename T> // For all the basic types which are not pointers
auto generate_FFI_types( const T& t ) -> std::enable_if_t< !is_reflection<T>::value && !std::is_pointer<T>::value > {
  generate_FFI_types( t );
}

//Special case for bool, since not provided by libffi. Must be inline (due to One Definition Rule) 
inline auto generate_FFI_types( const bool& t){ // ffi does not support bool, so we use for it the unsigned integer of the same size than the size the platform uses for the bool
    using bool_equiv_type = typename Bool_FFI<sizeof(bool)>::type;
    generate_FFI_types( bool_equiv_type{} );
    FFI_Type_Wrapper<bool_equiv_type> eq;
    FFI_Type_Wrapper<bool> baux;
    baux.ffiType = eq.ffiType;
}

template <typename T> // For all the pointers
auto generate_FFI_types( T* t ) -> std::enable_if_t< std::is_pointer<T>::value > {
  generate_FFI_types( static_cast<void*>(t) ); // By casting T* to void* we enforce calling to the correct "generate_FFI_types" generated by FFI_TYPEDEF_MOD(pointer, void*, FFI_TYPE_POINTER)
}



template <typename T, size_t N>
constexpr bool fields_index_0(const std::array<T, N>& array, const T& value) {
  if( array[0] == value )
    return true;
  return false;
}

/* process if T is a Tagged Union. To be treated as a tagged union, the struct must contain only two members, one integer type being the switchfield and the unnamed union member. */
template <typename T>
auto processTaggedUnion(T& t) -> std::enable_if_t< is_reflected_tagged_union<T>::value >  {
	using T_dec = typename std::decay<T>::type;	

    	using M = decltype(samy_reflect_members(std::forward<T>(t)));
    	using F = decltype( samy_reflect_fields(std::forward<T>(t)));
	constexpr auto member_names = M::member_names();
	constexpr auto number_fields = F::number_fields::value;

	/* In REFLECTION, does not matter whether fields or switchField go first */
        constexpr auto unionMemberName = F::get_union_member_name();
	constexpr int fieldsIndex = !!( !fields_index_0( member_names, unionMemberName) ); // If member_names[0] == unionMemberName, fields_index_0 returns 1 and fieldsIndex must be zero (hence the !)
	constexpr int switchFieldIndex = !!(!fieldsIndex); // opposite of fieldsIndex (1->0, 0->1) as integer (the !!)

    	constexpr auto tupleValues = M::apply_impl(); // Contains the pointers to switchField and fields
    	constexpr auto tupleFields = F::apply_impl(); // Contains the types and names of the members of the (unnamed) union "fields" in T (T the tagged union type)
       
        constexpr auto switchFieldPtr = std::get<switchFieldIndex>(tupleValues);
        auto switchFieldVal = t.*switchFieldPtr;

        generate_FFI_types( switchFieldVal );
	// We set the FFI type of the switchfield in the tagged union
	FFI_Type_Wrapper< T_dec >::type_elements[switchFieldIndex] = &FFI_Type_Wrapper< decltype(switchFieldVal) >::ffiType;

	for_each_union_field(t, // We generate and layout each reflected field of the unnamed union member of the tagged union
		[&](const auto& v, auto i) {	
                	generate_FFI_types( v );
        	}
	);

        constexpr auto unionFieldsPtr = std::get<fieldsIndex>(tupleValues);
        using auxiliar_type_member_union = typename std::decay< decltype( unionFieldsPtr ) >::type; // Given a tagged union TestUnion, this type is: TestUnion TestUnion::*

	/* I store the ffitype information of the unnamed member union ( std::get<switchFieldIndex>(tupleValues) ) in a FFI_Type_Wrapper that uses the type of the unnamed union member of the tagged union 		   ( TestUnion TestUnion::* ).
	   Hence, the tagged union FFI_Type_Wrapper has two type elements, one pointing to the integer type (switchfield), and one pointing to the type stored in the FFI_Type_Wrapper of the 		            auxiliar_type_member_union (TestUnion TestUnion::*) type.
	   The size and aligment of this FFI_Type_Wrapper<TestUnion TestUnion::*> (and hence the ffi type of the union member of the tagged union)
	   is computed in the next block (the union type will use the biggest size and biggest alignment of the members of the unnamed union)
	 */
	/* This is what appears in the libffi documentation for unions, but IT DOES NOT WORK!!!! libffi does not support unions at the moment. See: https://github.com/libffi/libffi/issues/33 */
	for_each_union_field(t,
		[&](const auto& v, auto i) {
			using v_type = typename std::decay< decltype(v) >::type;
		        if ( FFI_Type_Wrapper< v_type >::ffiType.size > FFI_Type_Wrapper< auxiliar_type_member_union >::ffiType.size )
			    FFI_Type_Wrapper< auxiliar_type_member_union >::ffiType.size = FFI_Type_Wrapper< v_type >::ffiType.size;

		        if ( FFI_Type_Wrapper< v_type >::ffiType.alignment > FFI_Type_Wrapper< auxiliar_type_member_union >::ffiType.alignment )
			    FFI_Type_Wrapper< auxiliar_type_member_union >::ffiType.alignment = FFI_Type_Wrapper< v_type >::ffiType.alignment;		    
        	}
	);

	FFI_Type_Wrapper< T_dec >::type_elements[fieldsIndex] = &FFI_Type_Wrapper< auxiliar_type_member_union >::ffiType;
}


template <typename T>
constexpr auto generate_FFI_types_composed( const T& t ) -> std::enable_if_t< is_reflection<T>::value > {
	  for_each(t, // We process each reflected member of the type
		[&t](const auto& v, auto i) {	
	  	    using M = decltype( samy_reflect_members( t ) );
	  	    constexpr auto Count = M::number_members::value;
		    constexpr auto member_names = M::member_names();
		    constexpr auto Idx = decltype(i)::value;

		    static_assert(Idx < Count);

   	    	    auto val = t.*v;

		    if constexpr ( is_reflected_tagged_union<T>::value && i==0 ) { //only processes once the tagged union (with the first member, hence i==0). A tagged union must have two members
		        static_assert( Count == 2, "Reflected tagged unions can only have two members, the switchfield and the unnamed union member" ); 
		        processTaggedUnion( t );
		    }else if constexpr( !is_reflected_tagged_union<T>::value ) { //processes the rest of types
		            generate_FFI_types( val ); // We need to generate the type of the member, since we will refer it within the "parent" type. Recursive generation of ffi types
		            if constexpr ( std::is_pointer<decltype(val)>::value ) { // If the current member is a pointer uses the ffi basic pointer type
		                    FFI_Type_Wrapper<T>::type_elements[Idx] = &FFI_Type_Wrapper< void* >::ffiType;		    
		            }else{
				    if constexpr ( is_reflection< decltype( val ) >::value ){	    
				            using K = decltype( samy_reflect_members( val ) );
					    constexpr auto CountAux  = K::number_members::value;
				            FFI_Type_Wrapper<T>::type_elements[Idx] = &FFI_Type_Wrapper< decltype(val) >::ffiType;			    
				    }else{
					    FFI_Type_Wrapper<T>::type_elements[Idx] = &FFI_Type_Wrapper< decltype(val) >::ffiType;
				    }
			    }
		            if( Idx == Count )
		                FFI_Type_Wrapper<T>::type_elements[Count + 1] = NULL; // FFI requires to the last element of the types' array to be NULL
		    }
       		 }
	);
}



} // ns FFI
} // ns Reflection
} // ns SAMY


